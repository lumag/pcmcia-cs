.\" Copyright (c) 1998 David Hinds <dhinds@hyper.stanford.edu>
.\" pcmcia.5 1.19 1998/01/13 15:48:26
.\"
.TH PCMCIA 5 "1998/01/13 15:48:26" "Stanford University"
.SH NAME
/etc/pcmcia/config \- PCMCIA card configuration database

.SH DESCRIPTION
The PCMCIA card configuration file is read by
.IR cardmgr (8)
at startup time.  It defines what resources are available for use by
Card Services, describes how to load and initialize device drivers,
and describes specific PCMCIA cards.

.SH Resource descriptions
There are three kinds of resource entries:
.BR include ,
.BR exclude ,
and
.BR reserve .
Including a resource enables Card Services to allocate
that resource for client drivers.  Part of a resource that is under
Card Services control can be excluded if a specific device in the
system uses that resource.  And, a resource can be reserved, so that
it will only be assigned to a client if that client specifically asks
for that resource, or no other suitable resources are available.
.PP
There are three resource types:
.BR port ,
.BR memory ,
and
.BR irq .
By default, Card Services assumes that it can use any interrupt that
is not bound by another device driver.  However, it makes no
assumptions about IO port and address ranges, because some Linux
drivers do not register their resource usage.  So, port and memory
ranges must be explicitly made available for use by PCMCIA devices.
.PP
So, here is a portion of a config file:
.sp
.RS
.nf
include port 0x300-0x3ff, memory 0xd0000-0xdffff
reserve irq 3
exclude irq 4, port 0x3f8-0x3ff
.RE
.fi
.sp
This says that Card Services can reserve ports in the range 0x300 to
0x3ff, and memory in the range 0xd0000 to 0xdffff.  It should not use
irq 4 or ports 0x3f8-0x3ff (even if they seem to be available).  And
irq 3 should only be allocated if a client specifically asks for it.
.PP
Card Services will never reserve resources actually reserved by
another device driver.  The
.BR include / exclude / reserve
mechanism just
provides a way of controlling what resources it will try to use, to
accomodate devices that are not registered with the Linux resource
manager.

.SH Device driver descriptions
All Card Services client drivers are identified by a 16-character tag.
.B Device
entries in the config file describe client drivers.  The only
required field is the device tag.  Additional fields can specify
kernel modules that need to be loaded to make the device available,
and a script to be executed to enable and disable instances of
a device.  When an instance of a driver is assigned to a socket, it
gives cardmgr a device name by which this device will be known by the
system (for example,
.I eth0
for a net device, or
.I cua1
for a modem).
This name will be passed to the configuration script.  For example:
.sp
.RS
.nf
device "pcnet_cs"
  class "network"
  module "net/8390" opts "ei_debug=4", "pcnet_cs"
.RE
.fi
.sp
This says that the
.B pcnet_cs
device requires two loadable modules.
The first one is located in the
.I net
module subdirectory and will be
loaded with a specific parameter setting.  The second module should be
in the
.I pcmcia
module subdirectory.  The device is in the network class, so the
.I network
script in the configuration directory will be used to start or stop
the device.
.PP
Configuration scripts are used to stop and start devices.  They are
also used to determine if a device is currently busy, to prepare a
device for a system suspend, and to wake up a device after a resume.
Cardmgr invokes a config script with several arguments: the action to
be performed, the device name, and the major and minor device numbers,
if applicable.

.SH Card descriptions
Card declarations map PCMCIA cards to their client drivers.  A card
declaration consists of a descriptive name, a method for identifying
the card when it is inserted, and driver bindings.  There are five
identification methods: the
.B version
method matches a card using its
VERSION_1 id strings, the
.B manfid
method matches a card using its MANFID tuple codes, the
.B tuple
method matches a card using any
string embedded in any arbitrary CIS tuple, the
.B function
method matches a card using its function ID, and the
.B anonymous
method matches any card that does not have a CIS.  This last method
is only intended to be used for old-style Type I memory cards.  For
example:
.sp
.RS
.nf
card "Linksys Ethernet Card"
  tuple 0x40, 0x0009, "E-CARD PC Ethernet Card"
  bind "pcnet_cs"
.RE
.fi
.sp
This card is identified by a string at offset 0x0009 in tuple 0x40,
and will be bound to the
.B pcnet_cs
driver (which must be already declared in a
.B driver
declaration).
.sp
.RS
.nf
card "Connectware LANdingGear Adapter"
  manfid 0x0057, 0x1004
  bind "pcnet_cs"
.RE
.fi
.sp
This card is identified by its MANFID tuple contents.
.sp
.RS
.nf
card "D-Link DE-650 Ethernet Card"
  version "D-Link", "DE-650"
  bind "pcnet_cs"
.RE
.fi
.sp
This card will be identified using its VERSION_1 tuple, and will also
be bound to the
.B pcnet_cs
driver.
.sp
.RS
.nf
card "Serial port device"
  function serial_port
  bind "serial_cs"
.RE
.fi
.sp
This binds the
.B serial_cs
driver to any card with a CIS function ID of
0x02, which corresponds to a serial port card.  The function ID can
either be a number, or one of the following predefined functions:
.BR memory_card ,
.BR serial_port ,
.BR parallel_port ,
.BR fixed_disk ,
.BR video_adapter ,
.BR network_adapter ,
and
.BR aims_card .

.SH Memory region definitions 
Memory region definitions are used to associate a particular type of
memory device with a Memory Technology Driver, or "MTD".  An MTD is
used to service memory accesses in a device-independent fashion.  When
a card is identified, Card Services will attempt to load MTD's for all
its memory regions.
.PP
A memory region definition begins with the
.B region
keyword and a descriptive string.  This is followed by an
identification method: either
.B default
to identify an MTD to be used for any otherwise unclassified region,
or
.B jedec
to identify a region based on its JEDEC identification codes.  Thus,
for example,
.sp
.RS
.nf
region "Intel Series 2 Flash"
  jedec 0x89 0xa2
  mtd "iflash2_mtd"
.RE
.fi
.sp
specifies that the
.B iflash2_mtd
driver will be loaded based on a JEDEC match.

.SH BUGS
The
.B reserve
keyword has not actually been implemented in a useful way for this
version of Card Services.
.SH AUTHOR
David Hinds \- dhinds@allegro.stanford.edu
.SH "SEE ALSO"
cardmgr(8).
